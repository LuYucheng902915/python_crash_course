# 在 Python 相关的项目中，除了约定俗成的工具文件（如 README）和类名，一切皆小写；用连字符命名仓库，用下划线命名代码文件夹/文件名，项目中的类似数据集 mnist 等文件夹，文件名也小写，既保持一致，又不易出错。

# 至此，已经掌握了编写整洁易用的程序所需的基本技能，该考虑让程序目标更明确、用途更大了。
# 在本章中，将学习处理文件，让程序能够快速地分析大量数据；你将学习错误处理，避免程序在面对意外情况时崩溃；你将学习异常，它们是 Python 创建的特殊对象，用于管理程序运行时出现的错误；你还将学习使用 json 模块保存用户数据，以免这些数据在程序结束运行后丢失。
# 学习处理文件和保存数据能让你的程序更易于使用：用户能够选择输入什么样的数据以及在什么时候输入；用户使用程序做完一些工作后，可先将程序关闭，以后再接着往下做。
# 学习处理异常可帮助你应对文件不存在等情况，以及处理其他可能导致程序崩溃的问题。
# 这让程序在面对错误的数据时更稳健——不管这些错误数据源自无意的错误，还是出于破坏程序的恶意企图。
# 在本章学习的技能可提高程序的适用性、可用性和稳定性。

# 读取文件。文本文件可存储的数据多得令人难以置信。
# 每当需要分析或修改存储在文件中的信息时，读取文件都很有用，对数据分析应用程序来说尤其如此。
# 例如，可以编写一个程序来读取文本文件的内容，并且以新的格式重写该文件，让浏览器能够显示。
# 要使用文本文件中的信息，首先需要将信息读取到内存中。
# 既可以一次性读取文件的全部内容，也可以逐行读取。
# 下面的程度打开并读取这个文件，再将其内容显示到屏幕上：
from pathlib import Path

path = Path("pi_digits.txt")
contents = path.read_text()
print(contents)
# VS Code 的 "Run Python File" 功能，默认将当前工作目录 (CWD) 设置为工作区的根目录 (${workspaceFolder})，而不是被执行的 .py 文件所在的目录。
# 所以运行代码会去根目录 python_crash_course 寻找文件。会发现找不到文件。
# 如果想让 VS Code 始终在文件所在目录执行，可以在设置中修改 "python.terminal.executeInFileDir": true。
# 这里改了配置，如果不改，就必须在 VSCode 打开当前 py 文件所在的文件夹。

# 要使用文件的内容，需要将其路径告知 Python。
# 路径（path）指的是文件或文件夹在系统中的准确位置。
# Python 提供了 pathlib 模块，能够更轻松地在各种操作系统中处理文件和目录。
# 提供特定功能的模块通常称为库（library）。这就是这个模块被命名为 pathlib 的原因所在。

# 这里首先从 pathlib 模块导入 Path 类。Path 对象指向一个文件，可用来做很多事情。
# 例如，在使用文件前核实它是否存在，读取文件的内容，以及将新数据写入文件。
# 这里创建了一个表示文件 pi_digits.txt 的 Path 对象，并将其赋给了变量 path。
# 由于这个文件与当前编写的 .py 文件位于同一个目录中，因此 Path 只需要知道其文件名就能访问它。
# 创建表示文件 pi_digits.txt 的 Path 对象后，使用 read_text() 方法来读取这个文件的全部内容。
# read_text() 将该文件的全部内容作为一个字符串返回，将这个字符串赋给了变量 contents。
# 在打印 contents 的值时，将显示这个文本文件的全部内容。

# pathlib.Path 对象本身不是文件，而是一个代表文件系统路径的 Python 对象。
# 它只是一个路径的表示：创建一个 Path 对象时，只是在内存里创建了一个指向某个路径的“指针”。
# 这个路径所对应的文件或目录可能存在，也可能完全不存在。
# 可以通过调用 Path 对象的方法来操作它所指向的真实文件或目录。

# 下面介绍一些 Windows 和 Linux 文件路径的常用知识。
# 两个系统都使用树状的层级结构来组织文件和目录。一个目录可以包含文件和其他目录，形成一个清晰的从属关系。
# 下面两行是相对路径中的特殊目录，在两个系统中完全通用。
# .. (双点)：代表当前目录的父目录（上一级目录）。例如，images/.. 最终会回到 images 所在的目录。
# . (单点)：代表当前目录本身。它在某些命令中用于明确指定当前路径。
# 根本区别：路径分隔符在 Windows 中是反斜杠 \，在 Linux 中是正斜杠 /。
# 这是最根本的区别。 Windows也部分支持 /，但标准是 \。
# 注意： 在很多编程语言中，\ 是转义字符，所以路径字符串常需写成 "C:\\Users\\Test" 或使用原始字符串 r"C:\Users\Test"。
# 原始字符串 (Raw String) 是 Python 中的一种特殊字符串类型，它的主要作用是“关闭”字符串内部的转义字符机制。
# 简单来说，在原始字符串中，所有的字符都代表其字面意义，尤其是反斜杠 \ 不再具有特殊的“转义”功能。
# 关于根目录：
# Windows: 文件系统是基于“盘符”的，拥有多个根目录。每个分区（如 C 盘、D 盘）都是一个独立的树状结构的起点。例如：C:\ 和 D:\。
# Linux: 文件系统拥有一个唯一的、统一的根目录，表示为 /。所有的硬件设备（包括硬盘、U 盘等）都会以目录的形式“挂载”到这个单一的根目录下，如 /mnt/data 或 /media/usb。
# 大小写敏感性:
# Windows: 默认情况下，路径不区分大小写。MyFile.txt 和 myfile.txt 被视为同一个文件。
# Linux: 路径严格区分大小写。MyFile.txt 和 myfile.txt 是两个完全不同的独立文件。这一点是跨平台开发时极易出错的地方。
# 家目录表示:
# Windows: 用户的家目录通常位于 C:\Users\<用户名>。在命令行中，可以通过环境变量 %USERPROFILE%(cmd) 或者 $env:USERPROFILE(powershell) 来访问。
# Linux: 用户的家目录通常位于 /home/<用户名>。在Shell环境中，可以使用波浪号 ~ 作为家目录的快捷方式。
# 非法字符 Windows: 文件名中禁止使用一些特殊字符，包括 < (小于), > (大于), : (冒号), " (双引号), / (正斜杠), \ (反斜杠), | (竖线), ? (问号), * (星号)。
# Linux: 文件名中限制极少，只有 / (因为它被用作路径分隔符) 和 null 字符是严格禁止的。其他特殊字符虽然技术上可用，但为了避免在命令行中产生混淆，通常不建议使用。

# 核心概念：当前工作目录 (Current Working Directory - CWD)。
# 定义：CWD 是程序执行时“站立”的位置，是所有相对路径的起点。它不一定等于 Python 脚本文件所在的位置。
# 如何确定 CWD：
# 命令行执行: CWD 取决于在哪个目录下执行 python 命令。
# cd /my_app 然后 python scripts/main.py -> CWD 是 /my_app。
# cd /my_app/scripts 然后 python main.py -> CWD 是 /my_app/scripts。
# IDE 执行 (如 VS Code): CWD 通常默认设置为打开的项目或工作区的根目录。。
# 两种路径方案的对比：当需要访问一个文件时，可以使用两种路径，都可以存储在 Path 对象中并指向对应的文件。
# 绝对路径 (Absolute Path)：
# 描述: 从文件系统的根目录开始的完整路径 (如 C:\Users\Test\file.txt 或 /home/test/file.txt)。
# 优点: 明确无误，无论从哪里运行脚本，总能指向同一个位置。
# 缺点: 不可移植。更换电脑、移动项目文件夹或分享给他人时，路径会立即失效。应避免在代码中硬编码。
# 相对路径 (Relative Path)
# 描述: 相对于当前工作目录 (CWD) 的路径 (如 data/file.txt 或 ../config.ini)。
# 优点: 可移植。只要项目内部结构不变，整个项目可以被随意移动。
# 缺点: 脆弱。它完全依赖于一个正确的 CWD。如果 CWD 与预期不符，程序将找不到文件。
# 黄金法则：编写健壮、可移植的路径代码。
# 目标是结合两者的优点：既要像相对路径一样可移植，又要像绝对路径一样可靠。
# 方法：以脚本文件自身的位置为“锚点”，动态构建路径。
# 这确保了无论 CWD 在哪里，总能从一个固定的、正确的起点开始寻找文件。Python 3 的 pathlib 库和魔法变量 __file__ 是实现此目的的最佳工具。

# 获取当前脚本文件所在的目录。
# Path(__file__) 获取脚本自身的完整路径。
# .parent 获取该路径的父目录。
# 这行代码是所有路径操作的“可靠锚点”。
script_dir = Path(__file__).parent

# 以此锚点为基准，使用 / 运算符拼接路径。
# 这比字符串拼接更清晰，且跨平台兼容。
# pathlib 对 / 运算符进行了“重载”（overloading）。
# “重载”是面向对象编程中的一个核心概念，它的思想非常直观。
# 通俗解释：让同一个运算符（比如 +, -, /）在面对不同类型的操作对象时，能有不同的、符合直觉的行为。
# 当  + 号两边是数字时，它执行的是数学加法，当 + 号两边是字符串时，它执行的是字符串拼接。
# 当它检测到在用 / 连接两个路径对象时，它不会简单地把它们当成字符串拼接。
# 相反，它会根据当前程序运行的操作系统（Windows、Linux 或 macOS），在生成最终的路径字符串时，自动使用该系统对应的正确分隔符。
data_file = script_dir / "data" / "my_data.csv"
config_file = script_dir.parent / "config" / "settings.ini"  # 访问上级目录中的文件

# 这样得到的路径是一个完整的、在任何环境下都正确的绝对路径。
print(f"最终的数据文件路径: {data_file}")
print(f"最终的配置文件路径: {config_file}")

# 现在可以放心使用这个路径进行文件操作了。
# with open(data_file, 'r') as f:
# 注意: __file__ 这个魔法变量在标准的 .py 文件执行时是可用的。
# 但是，在交互式环境（如 Jupyter Notebook、IPython 或标准 Python REPL）中运行代码时，__file__ 是未定义的，直接使用 Path(__file__) 会导致程序崩溃。
# 在这种交互式场景下，通常需要手动指定项目根目录，或者使用 os.getcwd() 作为基准。
# 更好的做法是将上述路径在代码开头定义为含义明确的常量。之后就可以用常量来构建路径。
# 更大的项目会将这些信息写入单独的配置文件中。


# 相比于原始文件，该输出唯一不同的地方是末尾多了一个空行。为何会多出这个空行呢？
# 因为 read_text() 在到达文件末尾时会返回一个空字符串，而这个空字符串会被显示为一个空行。
# 要删除这个多出来的空行，可对字符串变量 contents 调用 rstrip()。
contents = contents.rstrip()
print(contents)
# 读取文件并打印内容时，有些时候最后会显示一个空行。
# 但上面的解释是错误的，read_text() 会忠实地读取文件中的所有内容，不多也不少，并返回一个包含这些内容的字符串。
# 比如在上面的代码中， read_text() 返回字符串的末尾就没有空行。
# “多余空行”现象的真正原因是两个换行符 \n 的叠加：
# 文件自身的 \n：许多代码编辑器和自动格式化工具，为了遵循编程规范（POSIX标准），会在保存文件时自动在最后一行末尾确保有一个 \n。这是一个非常普遍的“最佳实践”。
# print() 函数的 \n: Python的 print() 函数在打印完提供的内容后，默认会自己再添加一个 \n，以便下次打印能从新的一行开始。
# 当 read_text() 读取了一个末尾带 \n 的文件后，print() 在打印这个字符串时，先是输出了文件自带的那个 \n（使光标换行），紧接着又输出了自己默认的 \n（使光标再次换行），从而产生了一个视觉上的多余空行。

# 为了避免这种双重换行，最健壮的方法是在打印前，使用 strip() 清理掉从文件中读出的字符串末尾可能存在的空白字符（包括换行符）。
# 文件末尾无 \n 的内部内容: "...\n第二行\n第三行"。编辑器显示: 能看到 3 行文字，光标会停留在“第三行”最后一个字的末尾。
# 文件末尾有 \n (常见情况)的内部内容: "...\n第二行\n第三行\n"。
# 文字内容：看起来仍然只有 3 行。视觉差异：光标会停在一个全新的、空的第 4 行的开头。
# VS Code等现代编辑器：为了清晰地向用户表明这个\n 的存在，可能会在行号栏里把这个空的第 4 行的行号（如 “4”）也显示出来。
# 文件末尾的 \n 在编辑器中不表现为一个可见的、有内容的空行，而是表现为“最后一行已被正确结束，光标已准备好进入新一行”。

# 为什么文件末尾“应该”有 \n？这是一个历史悠久且非常重要的编程规范（源于 POSIX 标准），主要原因有：
# 定义清晰：规范将“行”定义为“一串字符，并以 \n 结尾”。因此，一个格式完整的文本文件，它的每一行（包括最后一行）都应如此。
# 工具兼容性：许多命令行工具（如 cat, grep, wc 等）被设计用来逐行处理文本，它们依赖这个 \n 来识别行的结束。缺少它有时会导致格式或计数错误。
# 因此，编辑器自动添加末尾 \n 是一种保证文件格式规范和工具兼容性的“好习惯”。
# 当前使用的自动格式化工具保存文件后就会自动在文件最后一行代码的末尾加一个 \n。

# 在 VS Code 里创建了一个普通的 .txt 文件。对于这种通用文件类型，VS Code本身默认是“中立”的，它会忠实地保存您粘贴或输入的内容，不会做任何多余的修改。
# 自动添加 \n 这种行为，通常是由特定于文件类型的格式化工具触发的。
# 比如 VS Code 也可以使用 "files.insertFinalNewline": true，来设置。

# 要在读取文件内容时删除末尾的换行符，可在调用 read_text() 后直接调用方法 rstrip()：
contents = path.read_text().rstrip()
print(contents)
# 这行代码先让 Python 对当前处理的文件调用 read_text() 方法，再对 read_text() 返回的字符串调用 rstrip() 方法，然后将整理好的字符串赋给变量 contents。
# 这种做法称为方法链式调用（method chaining），在编程时很常用。


# 相对文件路径和绝对文件路径。
# 当将类似于 pi_digits.txt 这样的简单文件名传递给 Path 时，Python 将在当前执行的文件（即 .py 程序文件）所在的目录中查找（更准确的是 CWD）。
# 根据你组织文件的方式，有时可能要打开不在程序文件所属目录中的文件。
# 例如，可能将程序文件存储在了文件夹 python_work 中，并且在文件夹 python_work 中创建了一个名为 text_files 的文件夹，用于存储程序文件要操作的文本文件。
# 虽然文件夹 text_files 在文件夹 python_work 中，但仅向 Path 传递文件夹 text_files 中的文件的名称也是不可行的，因为 Python 只在文件夹 python_work 中查找，而不会在其子文件夹 text_files 中查找。
# 要让 Python 打开不与程序文件位于同一个目录中的文件，需要提供正确的路径。
# 在编程中，指定路径的方式有两种。首先，相对文件路径让 Python 到相对于当前运行的程序所在目录的指定位置（更准确的是相对于 CWD 的指定位置）去查找。
# 由于文件夹 text_files 位于文件夹 python_work 中，因此需要创建一个以 text_files 打头并以文件名结尾的路径，如下所示：
path = Path("text_files/filename.txt")
# 其次，可以将文件在计算机中的准确位置告诉 Python，这样就不用管当前运行的程序存储在什么地方了。
# 这称为绝对文件路径。在相对路径行不通时，可使用绝对路径。
# 假如 text_files 并不在文件夹 python_work 中，则仅向 Path 传递路径 'text_files/filename.txt' 是行不通的，因为 Python只在文件夹 python_work 中查找该位置。
# 为了明确地指出希望 Python 到哪里去查找，需要提供绝对路径。
# 绝对路径通常比相对路径长，因为它们以系统的根文件夹为起点：
path = Path("/home/eric/data_files/text_files/filename.txt")
# 使用绝对路径，可读取系统中任何地方的文件。
# 就目前而言，最简单的做法是，要么将数据文件存储在程序文件所在的目录中，要么将其存储在程序文件所在目录下的一个文件夹（如 text_files）中。
# 注意：在显示文件路径时，Windows 系统使用反斜杠（\）而不是斜杠（/）。
# 但是在代码中应该始终使用斜杠，即便在 Windows 系统中也是如此。
# 在与你或其他用户的系统交互时，pathlib 库会自动使用正确的路径表示方法。


# 访问文件中的各行：在使用文件时，经常需要检查其中的每一行，可能要在文件中查找特定的信息，或者以某种方式修改文件中的文本。
# 例如，在分析天气时，可能要遍历一个包含天气数据的文件，并使用天气描述中包含 sunny 字样的行；在新闻报道中，可能要查找包含标记 <headline> 的行，并按特定的格式改写它。
# 可以使用 splitlines() 方法将冗长的字符串转换为一系列行，再使用 for 循环以每次一行的方式检查文件中的各行：
lines = contents.splitlines()
print(lines)
for line in lines:
    print(line)
# splitlines() 方法返回一个列表，其中包含文件中所有的行，将这个列表赋给了变量 lines。然后，遍历这些行并打印它们：
# splitlines() 方法会根据换行符切分字符串，自动处理并丢弃换行符，返回的字符串是不包含换行符的。
lines_test = contents.split("\n")  # 功能与上面一样
print(lines_test)  # ['3.1415926535 ', '  8979323846 ', '  2643383279']
contents_test = contents + "\n"
lines_test = contents_test.split("\n")
print(lines_test)  # ['3.1415926535 ', '  8979323846 ', '  2643383279', '']
# split("\n") 与 splitlines() 都是根据换行符划分字符串。
# split("\n") 当原始字符串以 \n 结尾时，.split('\n') 会在切分后产生一个多余的空字符串 '' 在列表末尾。
# split() 方法的设计原则是返回所有“分隔符之间的内容”。当分隔符出现在字符串的末尾时，它后面依然存在一个“内容为空”的区域。
# .splitlines() 会智能地处理这种情况，不会产生这个多余的空字符串。
# 处理多种换行符：.splitlines() 还能自动识别并处理不同操作系统中的换行符，比如 Windows 的 \r\n。


# 将文件的内容读取到内存中后，就能以任意方式使用这些数据了。下面以简单的方式使用圆周率的值。
# 首先，创建一个字符串，它包含文件中存储的所有数字，不包含空格：
pi_string = ""
for line in lines:
    pi_string += line
print(pi_string)
print(len(pi_string))
# 变量 pi_string 存储的字符串包含原来位于每行左右两端的空格。要删除这些空格，可对每行调用 strip()：
pi_string = ""
for line in lines:
    pi_string += line.strip()
print(pi_string)
print(len(pi_string))
# 这样就获得了一个字符串，其中包含准确到 30 位小数的圆周率值。
# 这个字符串的长度是 32 个字符，因为它还包含整数部分的 3 和小数点：
# 在读取文本文件时，Python 将其中的所有文本都解释为字符串。
# 如果读取的是数，并且要将其作为数值使用，就必须使用 int() 函将其转换为整数，或者使用 float() 函数将其转换为浮点数。


# 尽管前面分析的都是一个只有三行的文本文件，但是这些代码示例也可以处理比它大得多的文件。
# 如果一个文本文件包含精确到小数点后 1 000 000 位而不是 30 位的圆周率值，也可以创建一个包含所有这些数字的字符串。
# 无须对前面的程序做任何修改，只需将这个文件传递给它即可。在这里，只打印到小数点后 50 位，以免终端花太多时间滚动显示全部的 1 000 000 位数字：
path = Path("pi_million_digits.txt")
contents = path.read_text()
lines = contents.splitlines()
pi_string = ""
for line in lines:
    pi_string += line.strip()

print(f"{pi_string[:52]}...")
print(len(pi_string))
# 在可处理的数据量方面，Python 没有任何限制。只要系统的内存足够大，想处理多少数据就可以处理多少数据。
# 下面来扩展刚才编写的程序，以确定某个人的生日是否包含在圆周率值的前 1 000 000 位中。为此，可先将生日表示为一个由数字组成的字符串，再检查这个字符串是否在 pi_string 中：
birthday = input("Enter your birthday, in the form mmddyy: ")
if birthday in pi_string:
    print("Your birthday appears in the first million digits of pi.")
else:
    print("Your birthday does not appear in the first million digits of pi.")

# 写入文件：保存数据的最简单的方式之一是将其写入文件。
# 通过将输出写入文件，即便关闭包含程序输出的终端窗口，这些输出也依然存在：
# 既可以在程序结束运行后查看这些输出，也可以与他人共享输出文件，还可以编写程序来将这些输出读取到内存中并进行处理。
# 定义一个文件的路径后，就可使用 write_text() 将数据写入该文件了。
# 为明白其中的工作原理，下面将一条简单的消息存储到文件中，而不将其打印到屏幕上：
path = Path("programming.txt")
path.write_text("I love programming.")
# write_text() 方法接受单个实参，即要写入文件的字符串。
# 这个程序没有终端输出，但如果打开文件 programming.txt，将看到一行内容。
# 这个文件与计算机中的其他文件没有什么不同。
# 可以打开它，在其中输入新文本，复制其内容，将内容粘贴到其中，等等。
# 注意：Python 只能将字符串写入文本文件。
# 如果要将数值数据存储到文本文件中，必须先使用函数 str() 将其转换为字符串格式。

# 写入多行write_text() 方法会在幕后完成几项工作。
# 首先，如果 path 变量对应的路径指向的文件不存在，就创建它。
# 其次，将字符串写入文件后，它会确保文件得以妥善地关闭。
# 如果没有妥善地关闭文件，可能会导致数据丢失或受损。
# 要将多行写入文件，需要先创建一个字符串（其中包含要写入文件的全部内容），再调用 write_text() 并将这个字符串传递给它。
# 下面将多行内容写入文件 programming.txt：
contents = "I love programming.\n"
contents += "I love creating new games.\n"
contents += "I also love working with data.\n"
path.write_text(contents)
# 首先定义变量 contents，用于存储要写入文件的所有内容。
# 接下来，使用运算符 += 在该变量中追加这个字符串。
# 可根据需要执行这种操作任意多次，以创建任意长度的字符串。
# 这里在每行末尾都添加了换行符，让每个句子都占一行。
# 如果运行这个程序，再打开文件 programming.txt，将发现上述每一行都在这个文本文件中：
# 也可以通过添加空格、制表符和空行来设置输出的格式，就像处理基于终端的输出那样。
# 对于字符串的长度没有任何限制。计算机生成的很多文件就是这样创建的。
# 注意：在对 path 对象调用 write_text() 方法时，务必谨慎。
# 如果指定的文件已存在， write_text() 将删除其内容，并将指定的内容写入其中。
# 本章后面将介绍如何使用 pathlib 检查指定的文件是否存在。


# 在现代 Python 编程中， with 用法被认为是处理文件等需要“获取”与“释放”资源的唯一正确方式。
# 下面将详细介绍一下。
# 早期打开文件的标准流程是三步：打开，操作，关闭。
# 传统方法
# f = open("my_file.txt", "w") # 打开文件
# f.write("Hello, world!") # 进行操作
# f.close() # 手动关闭文件
# 这个写法隐藏着一个巨大的风险：如果在操作过程中发生任何错误，f.close() 将永远不会被执行。
"""
f = open("my_file.txt", "w")
# 假设在这里，因为磁盘空间满了，或者其他任何原因，程序崩溃了！
data = 100 / 0 # 这里会发生 ZeroDivisionError 错误
f.write(str(data))

# 由于上面发生了错误，程序直接跳转到错误处理，下面这行代码永远不会被执行到
f.close() 
"""
# 这个文件句柄（file handle）会一直被程序占用着，操作系统会认为这个文件还在被打开。
# 如果程序是一个需要长时间运行的服务，这种忘记关闭的资源会越积越多，称之为“资源泄漏”（Resource Leak）。
# 最终，当泄漏的资源达到操作系统的上限时，整个程序会因为“打开的文件过多”而崩溃。
# 有经验的程序员会使用 try...finally 结构来确保关闭操作一定会被执行。
"""
# 使用 try...finally 的“安全”但繁琐的方法
f = open("my_file.txt", "w")
try:
    # 在 try 块里执行所有可能出错的操作
    data = 100 / 0
    f.write(str(data))
finally:
    # finally 块里的代码，无论 try 中是否发生错误，都保证会被执行
    print("确保关闭文件...")
    f.close()
"""
# 这个方法是安全的，但它非常繁琐和冗长。每次读写文件都要写这么一大块，很容易让人忘记。
# 现代解决方案：with 语句。with 语句其实就是 try-finally 结构的语法糖。
# 为了让代码既安全又简洁，Python引入了 with 语句，它也被称为上下文管理器 (Context Manager)。
"""
# 使用 with 语句的现代、安全、简洁的方法
with open("my_file.txt", "w") as f:
    print("进入with代码块，文件已打开。")
    # 在这个缩进的代码块内，可以安全地对 f 进行所有操作
    data = 100 / 0
    f.write(str(data))
    print("准备离开with代码块...")

# 一旦代码执行离开这个缩进块（无论是正常结束还是因为发生错误），
# Python会自动、保证地在背后调用 f.close()。
print("已经离开with代码块，文件已被自动关闭。")
"""
# with 语句的好处：自动管理资源，绝对安全。
# 这是它最重要的优点。无论 with 代码块内的操作是正常完成、因为异常（错误）而中断、还是因为 return 语句而退出，Python 都会保证在离开这个代码块时，执行必要的“清理”工作（比如 f.close()）。
# 再也不用担心忘记关闭文件而导致资源泄漏了。
# 代码更简洁、可读性更高。
# 相比于臃肿的 try...finally 结构，with 语句的意图非常清晰：“在这段代码里，我要使用这个叫 f 的文件资源”。代码的逻辑被清晰地组织在 with 块内，非常优雅。
# with 语句并非魔法，它依赖于一个叫做“上下文管理协议”的机制。任何一个对象，只要实现了 __enter__() 和 __exit__() 这两个特殊方法，就可以被用在 with 语句中。
# __enter__(): 在进入 with 代码块之前被调用。它的返回值会被赋给 as 后面的变量（比如 f）。
# __exit__(): 在离开 with 代码块之后被调用。清理工作（比如关闭文件）就在这个方法里完成。它还能接收到关于是否发生异常的信息，从而进行不同的处理。
# open() 函数返回的文件对象就内置了这两个方法，所以它天生就支持 with 语句。
# 对于 path 对象，它也有一个自己的 .open() 方法，用法与内置的 open() 函数完全类似。
"""
from pathlib import Path

# 首先，创建一个指向文件的Path对象
path = Path("pi_digits.txt")

# 然后，直接在 with 语句中使用这个 path 对象的 .open() 方法
# 这就是推荐的、结合了 pathlib 和 with 的写法
with path.open('r', encoding='utf-8') as f:
    # 在这里，f 就是我们熟悉的那个文件对象
    # 可以进行逐行读取等所有精细操作
    for line in f:
        print(line.strip())
"""
# path.open() 中，通常也明确指定编码（如 encoding='utf-8'），这是一个非常好的习惯，可以避免在不同操作系统上出现乱码问题。
# 何时使用 path.read_text() 和 path.write_text()？当需要一次性、一口气地处理整个文件时，用它们最方便。
# 前提是：确信文件不会太大，一次性读入内存是安全的。它的缺点是消耗内存。
# 何时使用 with path.open() as f:？
# 当需要更精细地控制文件，或者处理大文件时，必须使用它。它的优点是内存效率极高。
# 对于“读取全部内容”这种最简单的任务，代码比 .read_text() 稍微多一两行。
# 场景: 逐行处理文件（核心用法 for line in f:）。
# 处理一个巨大的文件，需要一次只读取一小块（比如 f.read(4096)）。
# 在一个循环中，分多次向同一个文件写入内容。
# 使用 csv、json 等模块来解析文件（例如 json.load(f)，这些模块被设计用来接收文件对象）。
# with open("my_file.txt", "w") as f:和 with path.open('w', encoding='utf-8') as f:
# 功能是完全一致的，with path.open(...) 本质上就是 pathlib 库为了方便，提供的一个快捷方式。
# 它在内部会调用 Python 内置的 open() 函数，并把 path 对象所代表的路径字符串传递给它。
# 简单路径: 如果路径很简单，或者是直接从用户输入获取的路径字符串，直接用 with open("my_file.txt", ...) 完全没问题。
# 复杂路径/程序内构建的路径: 如果文件路径是通过之前的逻辑（比如用 Path(__file__).parent.parent）构建出来的，那么用 with path.open(...) 就更加自然和连贯，代码可读性也更高。
# 当任务是“把文件所有内容一次性读出来”或“用一个字符串把文件整个覆盖掉”时，使用 path.read_text() 或 path.write_text()。它们代码最少，意图最清晰。
# 当需要逐行处理、分块读写、处理大文件，或者要将文件交给 csv/json 库处理时，必须使用 with path.open() as f:
# path 对象提供了一些高层级的“便捷方法”（Convenience Methods），这些方法在内部其实就是调用了文件对象 f 的基础功能来完成的。
# 当调用 .read_text() 时，pathlib 在后台默默地完成了三步操作：打开文件 (open(path, 'r'))，读取所有内容 (f.read())，关闭文件 (f.close())。它内部保证了之前所讨论的安全性。
# 它不仅仅是写起来更简单的“语法糖”，更是封装了健壮的错误处理和资源管理的“安全糖”。
"""
from pathlib import Path

path = Path("my_file.txt")
# 一行代码完成所有事
contents = path.read_text(encoding="utf-8") 
# 两者功能等价
from pathlib import Path

path = Path("my_file.txt")
with path.open(encoding="utf-8") as f:
    # f.read() 执行了和 .read_text() 内部一样的核心读取动作
    contents = f.read()
"""
# path (路径对象)：这是地址。它本身不是文件，只是一个包含了文件系统位置信息（如 "pi_digits.txt"）的对象。它的作用是“指路”。
# f (文件对象，也叫文件句柄)：这是根据地址找到房子后，拿到的“钥匙”和“打开的门”。
# 它代表了程序与硬盘上那个文件的一个活动的、打开的连接。所有的读写操作，都是通过这个“连接”来进行的。
# path 对象和文件对象 f 是两种角色不同、功能互补的工具。用一个“房地产中介和装修工人”的类比来理解。
# path 对象：是“房地产中介”。它的职责是处理与房屋本身（即文件在文件系统中的元数据和结构）相关的一切，而不是屋里的东西。
# path.exists(): “这个地址真的有房子吗？”
# path.is_file() / path.is_dir(): “这个地址上是栋别墅还是个停车场？”
# path.rename("new_name.txt"): “给这栋房子换个门牌号。”
# path.mkdir(): “在这块空地上打个地基盖个新房。”
# path.parent: “这条街的街名是什么？”
# f 对象：是“装修工人”它的职责是处理已经打开的房屋内部（即文件的内容数据流）。它不关心房子在哪条街上，只关心屋里的活儿。
# f.readline(): “把墙上第一行文字读下来。”
# f.read(1024): “从门口开始，量出1024个字节的数据。”
# f.write(...): “在墙上刷一条新标语。”
# f.seek(0): “回到门口（文件开头）。”
# path 对象处理的是文件系统层面的问题。
# 文件对象 f 处理的是文件内容层面的问题。
# 它们的功能是“协作”关系。而 path.open() 这个方法，就是那个连接二者的桥梁，相当于“中介”用地址找到了房子，然后把“钥匙”交给了“装修工人”。

# with path.open('w', encoding='utf-8') as f:
# 使用路径对象来打开文件，并得到一个文件对象”，然后再通过这个文件对象来处理文件。
# f 是程序与那个文件之间的一个活动的“连接”或“管道”。
# 可以把 f 想象成用来从井里打水的“水桶”。通过操作水桶（f.read(), f.readline()）来把井里的水（文件内容）一点点取出来。with 语句结束时，就是把这个“水桶”妥善地放好，盖上井盖。
# 创建一个 Path 对象，告诉程序文件的地址在哪里。
# 调用 path.open() 方法，打开这个地址上的文件，这会返回一个文件对象 f。
# 通过这个文件对象 f，进行逐行读取、分块写入等精细操作。
# with 语句结束时，自动关闭这个连接。

# for line in f: 的优势（内存效率）:这种逐行迭代的方式，每次只从硬盘读取一行内容到内存中进行处理，处理完就丢弃，然后再读取下一行。这意味着，无论文件是 1KB 还是 10GB，它占用的内存都非常小。
# 文件对象同样既是迭代器，也是可迭代对象。当对文件对象 f 使用 for 循环时，Python 向 f 索要一个迭代器（调用 f.__iter__()），而 f 直接把它自己返回了。
# 文件对象不是容器，因为它不能把文件内容全部存到内存中。
# 文件对象 f 是一个迭代器，它会记录当前读取到哪里的状态（一个指向文件字节位置的指针）。当它走到文件末尾时，它的状态就是“已耗尽”。
# 但是文件对象又很特殊，与 sys.stdin 这样的流不同，它不是真正意义上的“一次性消耗品”。这是因为它背后连接的是一个可以被随机访问的物理文件。
# f.seek(0) 的作用：这个方法就像是磁带机的“倒带”按钮。它告诉操作系统：“请把这个文件的读写指针（也就是迭代器的内部状态）重新移动到文件的最开始（第0个字节处）。
# 执行 f.seek(0) 后，那个“耗尽”的迭代器就“复活”了，可以重新对它进行 for 循环遍历。
# 标准迭代器 / sys.stdin：就像一个在线直播。数据流过一次就没了，错过了就错过了，无法对主播说“嘿，把你三分钟前说的话再重说一遍”，无法“倒带”。
# 文件对象 f：就像在您电脑上播放一个本地的视频文件。可以从头到尾顺序观看一遍（for line in f:）。观看结束后，视频也就“耗尽”了。
# 但因为完整的视频文件就存在您的硬盘上，可以随时拖动进度条（f.seek()）到任何一个时间点，包括拖回最开始（f.seek(0)），然后重新观看。

# 当文件被只读打开时，别的程序能修改文件吗？取决于操作系统， Windows 比较严格，对于 Linux 等其他的 POSIX 系统，通常比较宽松。
# 但这也会带来风险，第一个程序可能会在读取文件的过程中，读到一部分旧数据和一部分新修改的数据，导致数据不一致或程序出错。专业的应用程序在这种情况下需要使用“文件锁”（fcntl模块）等机制来确保数据完整性。

# Python 文件对象的核心，其实最重要的就是状态，这个状态代表了下一次读写操作应该从文件的第几个字节开始”，也就是字节偏移量（byte offset）。以及其他一些辅助信息。
# 当代码执行 f.read()、f.write() 或 f.seek() 时，Python会扮演一个“项目经理”的角色，它会把请求打包成一个标准化的指令，然后通过系统调用（System Call）的方式，把它“委托”给真正的“工人”——操作系统（Operating System）。


# 在现代 Python 中，处理文件路径的最佳实践始于 pathlib 库中的 Path 对象。
# 这个对象不仅能优雅地构建和操作路径，还提供了一系列强大的元数据检查功能，例如判断路径是否存在、是文件还是目录，还可以执行重命名或创建目录等文件系统级别的操作。
# 同时，它也封装了诸如 .read_text() 这样便捷的方法，用于一次性读写整个小文件。
# 然而，当需要对文件内容进行更精细、更通用的操作时，核心工具便切换为文件对象（通常在代码中写作 f）。
# 可以通过 Path 对象的 .open()方法，并结合 with 语句来安全地获取这个文件对象，with 语句能确保在操作结束后自动关闭文件，避免因程序异常而导致的资源泄漏。
# 这个文件对象在设计上非常精妙，它既是一个可迭代对象，也是其自身的迭代器，因此我们可以直接使用 for line in f: 来高效地逐行读取文件，这在处理大文件时极为节省内存。
# 它的核心状态是一个更为底层的“字节偏移量”，这个数字精确地指明了下一次读写操作在硬盘上的起始字节位置。
# 与普通的一次性迭代器不同，由于文件对象背后连接的是硬盘上可被随机访问的持久化数据，可以通过 .seek() 方法随时“倒带”，手动重置这个字节偏移量，从而实现对文件的重复读取。
# 最终，所有这些看似在 Python 层面进行的操作，无论是定位还是读写，实际上都是通过系统调用委托给了操作系统。
# 操作系统内核负责维护每个已打开文件的精确字节偏移量，执行物理硬盘的 I/O 操作，并管理数据缓冲以提升性能，而 Python 则为我们提供了调用这些底层功能的优雅、安全且跨平台的接口。
