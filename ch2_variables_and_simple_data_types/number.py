2 + 3
3 - 2
2 * 3
3 / 2
3**2
3**3
10**6
2 + 3 * 4
(2 + 3) * 4
0.1 + 0.1
0.2 + 0.2
2 * 0.1
2 * 0.2
0.2 + 0.1  # 0.30000000000000004
3 * 0.1  # 0.30000000000000004
# 永远不要假设浮点数的计算是完全精确的，也永远不要直接使用 == 来比较两个浮点数是否相等
# 0.2 + 0.1 == 0.3 # False
# 我们不应该检查两个浮点数是否“绝对相等”，而应该检查它们的差值是否在一个我们可以接受的极小范围（称为“容差”或“epsilon”）之内。
# 从Python 3.5开始，math 模块提供了一个非常方便的函数 isclose() 来完成这个任务。
# isclose(0.2 + 0.1, 0.3)  # True
# 当你的应用场景完全不能容忍任何微小误差时（例如金融计算、科学计数），就不应该使用标准的浮点数。Python为此提供了 Decimal 模块。
# Decimal 模块在计算时，会保留我们人类习惯的十进制表示，从而避免了二进制转换带来的精度损失。
# 上面这些均在解释器中运行


from decimal import Decimal

# 一开始文件名为numbers.py，但是decimal库要导入标准库numbers
# 根据Python的导入规则，它会优先在当前脚本所在的目录中寻找。
# 这造成导入时会优先找到我们自己的numbers.py文件，而不是标准库中的numbers模块。
# 形成死循环并报错，无法导入标准库中的numbers模块。
# 所以我们需要将文件名改为其他名称，避免与标准库冲突。

# 注意：为了精度，一定要用字符串来创建Decimal对象
a = Decimal("0.1")
b = Decimal("0.2")
c = Decimal("0.3")

print(a + b)  # 输出: 0.3
print(a + b == c)  # 输出: True

4 / 2  # 任意两个数相除，结果都是浮点数
# 无论是哪种运算，只要有操作数是浮点数，默认得到的就总是浮点数，即便结果原本为整数。
2 * 3.0  # 6.0
3.0**2  # 9.
1 + 2.0  # 3.0

universe_age = 14_000_000_000  # 使用下划线分隔数字，增加可读性
print(universe_age)  # 输出: 14000000000
# Python 会忽略其中的下划线,也适用于浮点数

x, y, z = 0, 0, 0
# 可在一行代码中给多个变量赋值，这有助于缩短程序并提高其可读性。这种做法最常用于将一系列数赋给一组变量。
# 需要用逗号将变量名分开；对于要赋给变量的值，也需要做同样的处理。
# Python 将按顺序将每个值赋给对应的变量。只要变量数和值的个数相同，Python 就能正确地将变量和值关联起来。

MAX_CONNECTIONS = 5000  # 常量，通常用大写字母表示
# 在Python中，常量并不是语言的内置特性，而是一个约定俗成的命名习惯。
# 通过将变量名全部大写，我们可以清楚地表明这个变量是一个常量，表示它的值在程序运行期间不会改变。
