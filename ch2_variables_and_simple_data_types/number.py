import math
from decimal import Decimal

# 一开始文件名为numbers.py，但是decimal库要导入标准库numbers。
# 根据Python的导入规则，它会优先在当前脚本所在的目录中寻找。
# 这造成导入时会优先找到我们自己的numbers.py文件，而不是标准库中的numbers模块。
# 形成死循环并报错，无法导入标准库中的numbers模块。
# 所以我们需要将文件名改为其他名称，避免与标准库冲突。


2 + 3
3 - 2
2 * 3
3 / 2
3**2
3**3
10**6
2 + 3 * 4
(2 + 3) * 4
# 整数运算。
# 浮点除法：精确除法运算，结果永远是浮点数：/
# 整除：执行除法，然后对结果向下取整（往负无穷方向取整）：//
# 取模/取余：计算两数相除后的余数。在Python中，余数的符号与除数（第二个数）的符号保持一致：%
# 满足恒等式：(a // b) * b + (a % b) == a。
# divmod(a, b) 将 a // b 和 a % b 的计算合二为一，返回一个包含商和余数的元组（tuple）。
q, r = divmod(-10, 3)
print(f"divmod(-10, 3) 的结果是: ({q}, {r})")
0.1 + 0.1
0.2 + 0.2
2 * 0.1
2 * 0.2
0.2 + 0.1  # 0.30000000000000004
3 * 0.1  # 0.30000000000000004
# 将带小数点的数称为浮点数。
# 永远不要假设浮点数的计算是完全精确的，也永远不要直接使用 == 来比较两个浮点数是否相等。
# 0.2 + 0.1 == 0.3 # False。
# 我们不应该检查两个浮点数是否“绝对相等”，而应该检查它们的差值是否在一个我们可以接受的极小范围（称为“容差”或“epsilon”）之内。
# 从Python 3.5开始，math 模块提供了一个非常方便的函数 isclose() 来完成这个任务。
# 当你的应用场景完全不能容忍任何微小误差时（例如金融计算、科学计数），就不应该使用标准的浮点数。Python为此提供了 Decimal 模块。
# Decimal 模块在计算时，会保留我们人类习惯的十进制表示，从而避免了二进制转换带来的精度损失。
# 上面这些均在解释器中运行，直接返回运算结果。

print(math.isclose(0.2 + 0.1, 0.3))  # True
# 注意：为了精度，一定要用字符串来创建Decimal对象。
a = Decimal("0.1")
b = Decimal("0.2")
c = Decimal("0.3")
print(a + b)  # 输出: 0.3
print(a + b == c)  # 输出: True

4 / 2  # 任意两个数相除，结果都是浮点数
# 无论是哪种运算，只要有操作数是浮点数，默认得到的就总是浮点数，即便结果原本为整数。
2 * 3.0  # 6.0
3.0**2  # 9.0
1 + 2.0  # 3.0

universe_age = 14_000_000_000  # 使用下划线分隔数字，增加可读性
print(universe_age)  # 输出: 14000000000
# Python 会忽略其中的下划线,也适用于浮点数。

x, y, z = 0, 0, 0
# 可在一行代码中给多个变量赋值，这有助于缩短程序并提高其可读性。这种做法最常用于将一系列数赋给一组变量。
# 需要用逗号将变量名分开；对于要赋给变量的值，也需要做同样的处理。
# Python 将按顺序将每个值赋给对应的变量。只要变量数和值的个数相同，Python 就能正确地将变量和值关联起来。
# 这个操作其实是可迭代对象（元组）的解包。
# “解包”指的是将一个可迭代对象（Iterable）中的元素，逐一地赋值给左侧的多个变量。

MAX_CONNECTIONS = 5000  # 常量，通常用大写字母表示
# 在Python中，常量并不是语言的内置特性，而是一个约定俗成的命名习惯。
# 通过将变量名全部大写，我们可以清楚地表明这个变量是一个常量，表示它的值在程序运行期间不会改变。
